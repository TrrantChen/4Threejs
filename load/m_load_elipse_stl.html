<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div style="width:100%;height:100%;background: red;">
        <canvas id="main" style="width:100%;height:100%;background: rgba(255,255,255,0);"> </canvas>
    </div>
</body>
<script src="../three/WebGL.js"></script>
<script src="../three/three.js"></script>
<script src="../three/stats.min.js"></script>
<script src="../three/STLLoader.js"></script>
<script src="../three/OrbitControls.js"></script>
<script src="../three/OBJLoader.js"></script>
<script>
    function init() {
        // 获取浏览器窗口的宽高，后续会用
        let width = window.innerWidth;
        let height = window.innerHeight;
        let mesh = void 0;
        let main = document.querySelector('#main');

        // 创建一个场景
        let scene = new THREE.Scene();

        // 创建一个具有透视效果的摄像机
        let camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 800);

        // 设置摄像机位置，并将其朝向场景中心
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 20;
        camera.lookAt(scene.position);

        // 创建一个 WebGL 渲染器，Three.js 还提供 <canvas>, <svg>, CSS3D 渲染器。
        let renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            canvas: main,
        });

        // 设置渲染器的清除颜色（即绘制下一帧前填充的颜色）和输出的 canvas 的尺寸
        // renderer.setClearColor(0x122222);
        renderer.setClearColor(0x000000);
        renderer.setSize(width, height);

        // 将渲染器的输出（此处是 canvas 元素）插入到 body
        // main.appendChild(renderer.domElement);

        // 初始化摄像机插件（用于拖拽旋转摄像机，产生交互效果）
        let orbitControls = new THREE.OrbitControls(camera);
        orbitControls.autoRotate = true;

        // let points;
        // 创建模型加载器
        // let loader = new THREE.OBJLoader();
        // loader.load('./model/one.obj', function (loadedMesh) {
        //
        //     console.log(JSON.stringify(loadedMesh));
        //
        //     let material = new THREE.PointsMaterial({
        //         color: 0xffffff,
        //         size: 0.4,
        //         // 使用 opacity 的前提是开启 transparent
        //         opacity: 0.6,
        //         transparent: true,
        //         // 设置元素与背景的融合模式
        //         blending: THREE.AdditiveBlending,
        //         // 指定粒子的纹理
        //         map: generateSprite(),
        //         // 用于去除纹理的黑色背景，关于 depthTest 和 depthWrite 的详细解释，请查看https://stackoverflow.com/questions/37647853/three-js-depthwrite-vs-depthtest-for-transparent-canvas-texture-map-on-three-p
        //         depthTest: false
        //     });
        //     loadedMesh.children.forEach(function (child) {
        //         let points = new THREE.Points(child.geometry, material);
        //         points.position.y = -2;
        //         scene.add(points);
        //     });
        // });

        let loader = new THREE.STLLoader();
        loader.load('../model/aaaaa.stl', function (geometry) {
            let material = new THREE.PointsMaterial({
                color: 0xffffff,
                // size: 4,
                size: 0.4,
                // 使用 opacity 的前提是开启 transparent
                opacity: 1,
                transparent: true,
                // 设置元素与背景的融合模式
                blending: THREE.AdditiveBlending,
                // 指定粒子的纹理
                map: generateSprite(),
                // 用于去除纹理的黑色背景，关于 depthTest 和 depthWrite 的详细解释，请查看https://stackoverflow.com/questions/37647853/three-js-depthwrite-vs-depthtest-for-transparent-canvas-texture-map-on-three-p
                depthTest: false
            });


            // loadedMesh.children.forEach(function (child) {
            //     let points = new THREE.Points(child.geometry, material);
            //     points.position.y = -2;
            //     scene.add(points);
            // });

            // let points = new THREE.Points(geometry, material);
            // points.position.y = -2;
            // scene.add(points);


            mesh = new THREE.Points(geometry, material);
            geometry.center(); //居中显示

            // mesh = new THREE.Points(geometry1, material);
            // geometry1.center(); //居中显示

            mesh.rotation.x = -0.5 * Math.PI; //将模型摆正
            //
            mesh.scale.set(0.1, 0.1, 0.1); //缩放



            scene.add(mesh);

        });


        // 生成纹理
        function generateSprite() {

            let canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;

            let context = canvas.getContext('2d');
            let gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(0,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(0,0,64,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);

            let texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;

        }

        render();

        function render() {
            // 渲染，即摄像机拍下此刻的场景
            renderer.render(scene, camera);

            if (mesh) {
                mesh.rotation.z += 0.0005;
            }
            requestAnimationFrame(render);
        }
    }

    init()
</script>
</html>
